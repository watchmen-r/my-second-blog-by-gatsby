{"componentChunkName":"component---src-pages-blog-post-tsx","path":"/event-loop/","result":{"data":{"site":{"siteMetadata":{"title":"Oda's web memo"}},"markdownRemark":{"id":"35a0a9bc-9b22-5f9b-9f22-dda2079fe895","excerpt":"I found a great book to study event loop and promise\nhttps://zenn.dev/estra/books/js-async-promise-chain-event-loop These knowledge are imperative in the tech…","html":"<p>I found a great book to study event loop and promise\n<a href=\"https://zenn.dev/estra/books/js-async-promise-chain-event-loop\">https://zenn.dev/estra/books/js-async-promise-chain-event-loop</a></p>\n<p>These knowledge are imperative in the tech interview, and knowing these spec enhances our productivity. So I want to summarize it.</p>\n<h1>Asynchronous api</h1>\n<p>We should understand what the asynchronous apis are at first. As for setTimeout() and console.log are not defined by ECMA script, but defined by environment like a V8 engine.\nFor example, comparing Node’s setTimeout() and browser’s setTimeout(), Node’s one is implemented as a copy of browser one, but slightly different according to the node documentation.</p>\n<h1>Event loop</h1>\n<p>Event loop is not defined by ECMA script. So this should be implemented by environment like a browser or runtime( node, demo). There would be able to exist multiple task queue. For example, blink, which is a rendering engine in chrome, prioritize to process click event.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/d5bfb/javascript_env.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.25316455696203%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGUlEQVR42oWS72tbVRjH80pty7Cl0y236UAUBUHBd+J0ssFwL9ZNRPtCX/lW/At8ISLIWB2VOme35YdN27S6ZklTlaEtuiEi6+xqZ5ts6b03P06yNG3Sm2SuTZPc85GbZCwbgg9873meL5fPec45j63HGcXu0ekYVmmvS6Ptqwhtp8PNWqVtWOXxcxoOj06XM8ZjQ3/z6Infaf86yl63To9Hl46xNIpbEzbLeGZc8Nl8jqG/NhlcNBiczzD4h+ALK7++yZklgw8vZ+lyJXj35zXOXLvNqctRBq6t8+Jkkiedq9IxKlA8MWHb7dR41S8wTYkVje/9MGXDWcxu0e3SCarFel1r+u+ENDo+/lEqA1ewD680gRcFFVNSk1CRULVkNtad5kYLTWBgtQEs12R987eDKh0fTUvl8yvYz0aEbbdL4+UpQaVWq/fX+O2+atKsA/5cu0u3J4F/tbVDyZvTOrs+nZUO5y0Ub0LYFI9OjzfJfr/g0JTOwYDgjVCaI6E0BwMpDgVTHA4KXvDe4pGhMM+OqBwOpev+gYuCXm/SAkmHL4MyErceReM5XxLXssFkZJNptcgHv67x/mymfrzRcIGxsMHkjQzB5TTfLa8zFikyHikwHjF4xS94whOXvRNrDWC3U+O1QIqtOyUKGxn4J8+cmmdiJffA5beGbMn6L92m0xWX++4B7z3KTrXK9k4FZJW5RIkT8xuI4g7LG2XCOUvbhHNbzbXhRXLbHAml6Ha3AK0OXw8IClsmv2lVohnJ1cxdnvcleOt7Qd+M4NiMoO9CmKO+Jfou3OTYTIrjM4KjIcFTo0mUEesOW4AHAoI7ZQtYYTVr8kuiyNnFdaQ0yW9XKJSrFMq1pqoY9bpKsVzh+A9putwPHFmV+/1JazikaTZmZS5WkL6VfD2v8dAcPaT+S2nZ6Y6b+yYy9HjjSZv9mzhPT6T55GqeU4sGp5cM3pvN0v9Tli+XDE4uGAxc/2+dXNjkpak0e7xC9n67geJNCZtyPlqye2KljmG11NZU5zmt1HVeq+ft/6M9br2kuPWi4omV7W715r+ipXCpiLl2hgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Event_loop\"\n        title=\"\"\n        src=\"/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/f058b/javascript_env.png\"\n        srcset=\"/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/c26ae/javascript_env.png 158w,\n/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/6bdcf/javascript_env.png 315w,\n/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/f058b/javascript_env.png 630w,\n/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/40601/javascript_env.png 945w,\n/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/d5bfb/javascript_env.png 1072w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>JavaScript is a single thread programming language, and this means, program is executed by single thread and have single call stack.\nIf RuntimeAPI like fetch() blocks the process, main process would have to wait until fetch() is finished.\nSo to avoid these situations, Javascript engine doesn’t involve to RuntimeAPI such a fetch(), and when the fetch() gets the data, notice to JavaScript engine with data to register the callback function.</p>\n<h2>Task queue</h2>\n<p>TBD\nPublished by setTimeout and so on</p>\n<h2>Micro task queue</h2>\n<p>TBD\nPublished by promise. This queue is prioritized to process when one task would be finished(in other words, when call stacks would be empty). Then all micro task queue would be processed.</p>\n<h1>About V8 (index of 8)</h1>\n<p>V8 is a javascript engine provided by Google. This engine is implemented by C++. This has basic default Event loop, task queue, and micro task queue.</p>\n<h1>Promise constructor and execute function (index of 12)</h1>\n<p>This is interesting chapter.</p>\n<p>These statements are nearly equal.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const promise1 = Promise.resolve(‘promise履行時の値’);\nconst promise2 = new Promise(res => res(‘promise履行時の値’);</code></pre></div>\n<h1>Issued micro task even if callback isn’t executed(index of 22)</h1>\n<p>Even if catch and then wouldn’t be executed because above promise is resolved or rejected, these microtask is published.</p>\n<h1>Interesting(difficult) event loop question at index24</h1>\n<p>Just a memo</p>\n<h1>The interesting spec of async and await at index26</h1>\n<p>async function is executed synchronously if there wouldn’t be await statement. This mean async would be ruin if it wouldn’t have await in his process. This effect is written in MDN doc.\nAs for promise, microtask queue is issued when then method is called. It’s same for await. When calls await, microtask queue is issued (Of course the spec in detail is different, but behavior is like that.)</p>\n<h3>Caution</h3>\n<p>In fact, await doesn’t block the all process.(this is confusion point because of meaning word).as I mentioned above, we can rewrite it using promise chain. Await’s really meaning is “continue another process in main thread!”</p>\n<h1>Promise status (index ?)</h1>\n<p>Knowing the promise status</p>\n<h1>Convert from async/await statement to promise chain</h1>\n<p><a href=\"https://zenn.dev/estra/books/js-async-promise-chain-event-loop/viewer/14-epasync-chain-to-async-await\">https://zenn.dev/estra/books/js-async-promise-chain-event-loop/viewer/14-epasync-chain-to-async-await</a>\nAs for promise is executed as an asynchronous process when using then method. It is same to async. Async would be asynchronous process when await is used. If there is no await in async, this process is executed same to promise which doesn’t have any then method.\nIn async function, the execution flows are divided by await statement. Look at this code as below.<br>\nCopied from the above page.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(async () => {\n  // 分割された実行フロー(0): 同期  → 最初の await までは同期的に処理される\n  // &lt;------------------->\n  await 1;\n  // 分割された実行フロー(1): 非同期 → イベントループでマイクロタスクとして処理される\n  // &lt;------------------->\n  await 2;\n  // 分割された実行フロー(2): 非同期 → イベントループでマイクロタスクとして処理される\n  // &lt;------------------->\n  await 3;\n  // 分割された実行フロー(3): 非同期 → イベントループでマイクロタスクとして処理される\n})();</code></pre></div>\n<p>We can consider then method is used when await is executed.<br>\n(Copied from the above page.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(\"🦖 [1] sync\");\n\n(async () => {\n  console.log(\"🦄 [2] sync\");\n  // ここまでは同期処理!!\n\n  // await のたびに then しているのと同じ\n  await Promise.resolve(1);\n  console.log(\"👻 [4] async\");\n  await Promise.resolve(2);\n  console.log(\"👻 [5] async\");\n})();\n\nconsole.log(\"🦖 [3] sync\");\n\n/* 出力結果\n🦖 [1] sync\n🦄 [2] sync\n🦖 [3] sync\n👻 [4] async\n👻 [5] async\n*/</code></pre></div>\n<p>The above code can be written like this.\n(Copied from the above page.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(\"🦖 [1] sync\");\n\n(async () => {\n  console.log(\"🦄 [2] sync\");\n\n  Promise.resolve(1)\n    .then(() => { // 非同期\n      console.log(\"👻 [4] async\");\n      return Promise.resolve(2);\n    })\n    .then(() => { // 非同期\n      console.log(\"👻 [5] async\");\n    });\n})();\n\nconsole.log(\"🦖 [3] sync\");\n\n/* 出力結果\n🦖 [1] sync\n🦄 [2] sync\n🦖 [3] sync\n👻 [4] async\n👻 [5] async\n*/</code></pre></div>\n<h1>Iterate Promise using reduce to run sequentially, avoid using for loop.</h1>\n<p>When we want to implement process of asynchronous sequentially, easy to use for loop. But in that case, advised by lint with airbnb that you have to avoid using for loop.\nTo avoid this lint error, we can use reduce.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(async () => {\n  for (let i = 0; i &lt; urls.length; i++) {\n    await fetchThenConsole(urls[i]);\n    // fetchThenConsole() は async 関数\n    console.log(`${i + 1}個目のフェッチが完了しました`);\n  }\n  console.log(\"すべての非同期処理が完了しました\");\n})();</code></pre></div>\n<p>Using reduce</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(async () => {\n  console.log(\"１秒ごとにアルファベットの出力を開始します\");\n\n  const pChain = chars.reduce((promise, item) => {\n    return promise.then(() => {\n        console.log(item);\n        return sleep(100); // 副作用にならないように return する sleep はasync 関数\n      });\n    }, sleep(1000));\n  await pChain;\n\n  console.log(\"すべてのアルファベットを出力しました\");\n})();</code></pre></div>\n<p>Let’s look at above process in detail. At first we define ‘’Promise.resolve()’ as an argument, this means initial value is Promise.resolve().\nPromise.resolve returns promise instance, so the reduce process get promise instance from promise arguments(first line), and run asynchronous function sequentially in then method.\nI think using for loop is readable, but I should understand how to avoid advice from lint with airbnb.</p>","frontmatter":{"title":"Event loop promise chain book summary","date":"July 25, 2024","description":"I found a great book to study event loop and promise. This knowledge is imparative to understand asynchronous process in JavaScript field. Unfortunately I couldn't find good materials in Japanese in the past. But recently, I found it. To understand more, I want to summarize it."}},"previous":{"fields":{"slug":"/How-to-write-Java17/"},"frontmatter":{"title":"How to write Java 17."}},"next":{"fields":{"slug":"/shader-each-matrix-means/"},"frontmatter":{"title":"What each matrix means in vertex shader."}}},"pageContext":{"id":"35a0a9bc-9b22-5f9b-9f22-dda2079fe895","previousPostId":"1a3400b6-53b9-558f-9f41-65dc9d7e1ce9","nextPostId":"151d4207-bb97-5dfc-8ab0-5d1fd6596ace"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}