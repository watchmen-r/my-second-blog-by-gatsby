{"componentChunkName":"component---src-pages-blog-post-tsx","path":"/event-loop/","result":{"data":{"site":{"siteMetadata":{"title":"Oda's web memo"}},"markdownRemark":{"id":"35a0a9bc-9b22-5f9b-9f22-dda2079fe895","excerpt":"I found a great book to study event loop and promise\nhttps://zenn.dev/estra/books/js-async-promise-chain-event-loop These knowledge are imperative in the techâ€¦","html":"<p>I found a great book to study event loop and promise\n<a href=\"https://zenn.dev/estra/books/js-async-promise-chain-event-loop\">https://zenn.dev/estra/books/js-async-promise-chain-event-loop</a></p>\n<p>These knowledge are imperative in the tech interview, and knowing these spec enhances our productivity. So I want to summarize it.</p>\n<h1>Asynchronous api</h1>\n<p>We should understand what the asynchronous apis are at first. As for setTimeout() and console.log are not defined by ECMA script, but defined by environment like a V8 engine.\nFor example, comparing Nodeâ€™s setTimeout() and browserâ€™s setTimeout(), Nodeâ€™s one is implemented as a copy of browser one, but slightly different according to the node documentation.</p>\n<h1>Event loop</h1>\n<p>Event loop is not defined by ECMA script. So this should be implemented by environment like a browser or runtime( node, demo). There would be able to exist multiple task queue. For example, blink, which is a rendering engine in chrome, prioritize to process click event.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/d5bfb/javascript_env.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.25316455696203%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGUlEQVR42oWS72tbVRjH80pty7Cl0y236UAUBUHBd+J0ssFwL9ZNRPtCX/lW/At8ISLIWB2VOme35YdN27S6ZklTlaEtuiEi6+xqZ5ts6b03P06yNG3Sm2SuTZPc85GbZCwbgg9873meL5fPec45j63HGcXu0ekYVmmvS6Ptqwhtp8PNWqVtWOXxcxoOj06XM8ZjQ3/z6Infaf86yl63To9Hl46xNIpbEzbLeGZc8Nl8jqG/NhlcNBiczzD4h+ALK7++yZklgw8vZ+lyJXj35zXOXLvNqctRBq6t8+Jkkiedq9IxKlA8MWHb7dR41S8wTYkVje/9MGXDWcxu0e3SCarFel1r+u+ENDo+/lEqA1ewD680gRcFFVNSk1CRULVkNtad5kYLTWBgtQEs12R987eDKh0fTUvl8yvYz0aEbbdL4+UpQaVWq/fX+O2+atKsA/5cu0u3J4F/tbVDyZvTOrs+nZUO5y0Ub0LYFI9OjzfJfr/g0JTOwYDgjVCaI6E0BwMpDgVTHA4KXvDe4pGhMM+OqBwOpev+gYuCXm/SAkmHL4MyErceReM5XxLXssFkZJNptcgHv67x/mymfrzRcIGxsMHkjQzB5TTfLa8zFikyHikwHjF4xS94whOXvRNrDWC3U+O1QIqtOyUKGxn4J8+cmmdiJffA5beGbMn6L92m0xWX++4B7z3KTrXK9k4FZJW5RIkT8xuI4g7LG2XCOUvbhHNbzbXhRXLbHAml6Ha3AK0OXw8IClsmv2lVohnJ1cxdnvcleOt7Qd+M4NiMoO9CmKO+Jfou3OTYTIrjM4KjIcFTo0mUEesOW4AHAoI7ZQtYYTVr8kuiyNnFdaQ0yW9XKJSrFMq1pqoY9bpKsVzh+A9putwPHFmV+/1JazikaTZmZS5WkL6VfD2v8dAcPaT+S2nZ6Y6b+yYy9HjjSZv9mzhPT6T55GqeU4sGp5cM3pvN0v9Tli+XDE4uGAxc/2+dXNjkpak0e7xC9n67geJNCZtyPlqye2KljmG11NZU5zmt1HVeq+ft/6M9br2kuPWi4omV7W715r+ipXCpiLl2hgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Event_loop\"\n        title=\"\"\n        src=\"/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/f058b/javascript_env.png\"\n        srcset=\"/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/c26ae/javascript_env.png 158w,\n/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/6bdcf/javascript_env.png 315w,\n/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/f058b/javascript_env.png 630w,\n/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/40601/javascript_env.png 945w,\n/my-second-blog-by-gatsby/static/3e610d48d82163fb0e2001b52449707f/d5bfb/javascript_env.png 1072w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>JavaScript is a single thread programming language, and this means, program is executed by single thread and have single call stack.\nIf RuntimeAPI like fetch() blocks the process, main process would have to wait until fetch() is finished.\nSo to avoid these situations, Javascript engine doesnâ€™t involve to RuntimeAPI such a fetch(), and when the fetch() gets the data, notice to JavaScript engine with data to register the callback function.</p>\n<h2>Task queue</h2>\n<p>TBD\nPublished by setTimeout and so on</p>\n<h2>Micro task queue</h2>\n<p>TBD\nPublished by promise. This queue is prioritized to process when one task would be finished(in other words, when call stacks would be empty). Then all micro task queue would be processed.</p>\n<h1>About V8 (index of 8)</h1>\n<p>V8 is a javascript engine provided by Google. This engine is implemented by C++. This has basic default Event loop, task queue, and micro task queue.</p>\n<h1>Promise constructor and execute function (index of 12)</h1>\n<p>This is interesting chapter.</p>\n<p>These statements are nearly equal.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const promise1 = Promise.resolve(â€˜promiseå±¥è¡Œæ™‚ã®å€¤â€™);\nconst promise2 = new Promise(res => res(â€˜promiseå±¥è¡Œæ™‚ã®å€¤â€™);</code></pre></div>\n<h1>Issued micro task even if callback isnâ€™t executed(index of 22)</h1>\n<p>Even if catch and then wouldnâ€™t be executed because above promise is resolved or rejected, these microtask is published.</p>\n<h1>Interesting(difficult) event loop question at index24</h1>\n<p>Just a memo</p>\n<h1>The interesting spec of async and await at index26</h1>\n<p>async function is executed synchronously if there wouldnâ€™t be await statement. This mean async would be ruin if it wouldnâ€™t have await in his process. This effect is written in MDN doc.\nAs for promise, microtask queue is issued when then method is called. Itâ€™s same for await. When calls await, microtask queue is issued (Of course the spec in detail is different, but behavior is like that.)</p>\n<h3>Caution</h3>\n<p>In fact, await doesnâ€™t block the all process.(this is confusion point because of meaning word).as I mentioned above, we can rewrite it using promise chain. Awaitâ€™s really meaning is â€œcontinue another process in main thread!â€</p>\n<h1>Promise status (index ?)</h1>\n<p>Knowing the promise status</p>\n<h1>Convert from async/await statement to promise chain</h1>\n<p><a href=\"https://zenn.dev/estra/books/js-async-promise-chain-event-loop/viewer/14-epasync-chain-to-async-await\">https://zenn.dev/estra/books/js-async-promise-chain-event-loop/viewer/14-epasync-chain-to-async-await</a>\nAs for promise is executed as an asynchronous process when using then method. It is same to async. Async would be asynchronous process when await is used. If there is no await in async, this process is executed same to promise which doesnâ€™t have any then method.\nIn async function, the execution flows are divided by await statement. Look at this code as below.<br>\nCopied from the above page.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(async () => {\n  // åˆ†å‰²ã•ã‚ŒãŸå®Ÿè¡Œãƒ•ãƒ­ãƒ¼(0): åŒæœŸ  â†’ æœ€åˆã® await ã¾ã§ã¯åŒæœŸçš„ã«å‡¦ç†ã•ã‚Œã‚‹\n  // &lt;------------------->\n  await 1;\n  // åˆ†å‰²ã•ã‚ŒãŸå®Ÿè¡Œãƒ•ãƒ­ãƒ¼(1): éåŒæœŸ â†’ ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã§ãƒã‚¤ã‚¯ãƒ­ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†ã•ã‚Œã‚‹\n  // &lt;------------------->\n  await 2;\n  // åˆ†å‰²ã•ã‚ŒãŸå®Ÿè¡Œãƒ•ãƒ­ãƒ¼(2): éåŒæœŸ â†’ ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã§ãƒã‚¤ã‚¯ãƒ­ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†ã•ã‚Œã‚‹\n  // &lt;------------------->\n  await 3;\n  // åˆ†å‰²ã•ã‚ŒãŸå®Ÿè¡Œãƒ•ãƒ­ãƒ¼(3): éåŒæœŸ â†’ ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã§ãƒã‚¤ã‚¯ãƒ­ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†ã•ã‚Œã‚‹\n})();</code></pre></div>\n<p>We can consider then method is used when await is executed.<br>\n(Copied from the above page.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(\"ğŸ¦– [1] sync\");\n\n(async () => {\n  console.log(\"ğŸ¦„ [2] sync\");\n  // ã“ã“ã¾ã§ã¯åŒæœŸå‡¦ç†!!\n\n  // await ã®ãŸã³ã« then ã—ã¦ã„ã‚‹ã®ã¨åŒã˜\n  await Promise.resolve(1);\n  console.log(\"ğŸ‘» [4] async\");\n  await Promise.resolve(2);\n  console.log(\"ğŸ‘» [5] async\");\n})();\n\nconsole.log(\"ğŸ¦– [3] sync\");\n\n/* å‡ºåŠ›çµæœ\nğŸ¦– [1] sync\nğŸ¦„ [2] sync\nğŸ¦– [3] sync\nğŸ‘» [4] async\nğŸ‘» [5] async\n*/</code></pre></div>\n<p>The above code can be written like this.\n(Copied from the above page.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(\"ğŸ¦– [1] sync\");\n\n(async () => {\n  console.log(\"ğŸ¦„ [2] sync\");\n\n  Promise.resolve(1)\n    .then(() => { // éåŒæœŸ\n      console.log(\"ğŸ‘» [4] async\");\n      return Promise.resolve(2);\n    })\n    .then(() => { // éåŒæœŸ\n      console.log(\"ğŸ‘» [5] async\");\n    });\n})();\n\nconsole.log(\"ğŸ¦– [3] sync\");\n\n/* å‡ºåŠ›çµæœ\nğŸ¦– [1] sync\nğŸ¦„ [2] sync\nğŸ¦– [3] sync\nğŸ‘» [4] async\nğŸ‘» [5] async\n*/</code></pre></div>\n<h1>Iterate Promise using reduce to run sequentially, avoid using for loop.</h1>\n<p>When we want to implement process of asynchronous sequentially, easy to use for loop. But in that case, advised by lint with airbnb that you have to avoid using for loop.\nTo avoid this lint error, we can use reduce.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(async () => {\n  for (let i = 0; i &lt; urls.length; i++) {\n    await fetchThenConsole(urls[i]);\n    // fetchThenConsole() ã¯ async é–¢æ•°\n    console.log(`${i + 1}å€‹ç›®ã®ãƒ•ã‚§ãƒƒãƒãŒå®Œäº†ã—ã¾ã—ãŸ`);\n  }\n  console.log(\"ã™ã¹ã¦ã®éåŒæœŸå‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸ\");\n})();</code></pre></div>\n<p>Using reduce</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(async () => {\n  console.log(\"ï¼‘ç§’ã”ã¨ã«ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã®å‡ºåŠ›ã‚’é–‹å§‹ã—ã¾ã™\");\n\n  const pChain = chars.reduce((promise, item) => {\n    return promise.then(() => {\n        console.log(item);\n        return sleep(100); // å‰¯ä½œç”¨ã«ãªã‚‰ãªã„ã‚ˆã†ã« return ã™ã‚‹ sleep ã¯async é–¢æ•°\n      });\n    }, sleep(1000));\n  await pChain;\n\n  console.log(\"ã™ã¹ã¦ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã‚’å‡ºåŠ›ã—ã¾ã—ãŸ\");\n})();</code></pre></div>\n<p>Letâ€™s look at above process in detail. At first we define â€˜â€™Promise.resolve()â€™ as an argument, this means initial value is Promise.resolve().\nPromise.resolve returns promise instance, so the reduce process get promise instance from promise arguments(first line), and run asynchronous function sequentially in then method.\nI think using for loop is readable, but I should understand how to avoid advice from lint with airbnb.</p>","frontmatter":{"title":"Event loop promise chain book summary","date":"July 25, 2024","description":"I found a great book to study event loop and promise. This knowledge is imparative to understand asynchronous process in JavaScript field. Unfortunately I couldn't find good materials in Japanese in the past. But recently, I found it. To understand more, I want to summarize it."}},"previous":{"fields":{"slug":"/How-to-write-Java17/"},"frontmatter":{"title":"How to write Java 17."}},"next":{"fields":{"slug":"/shader-each-matrix-means/"},"frontmatter":{"title":"What each matrix means in vertex shader."}}},"pageContext":{"id":"35a0a9bc-9b22-5f9b-9f22-dda2079fe895","previousPostId":"1a3400b6-53b9-558f-9f41-65dc9d7e1ce9","nextPostId":"151d4207-bb97-5dfc-8ab0-5d1fd6596ace"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}